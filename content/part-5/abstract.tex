\chapter*{mmdb}

\section*{Overview}

\obj{mmdb}\footnote{\url{https://github.com/fdch/mmdb}} is a multimodal database system geared towards live querying of image an audio. It consists of a series of bash and python scripts that surround and aid the performance of Pure Data patches. A multimodal database combines two sensing modes. In this sense, the camera sensor and the microphone.

The system enables you to load a folder with images with various formats and sizes, analyze them, and output a database describing the images with some useful keywords (descriptors). The images can be either taken and collected by you, obtained from the web, or generated by some other means. The analysis is done after normalizing these images to the same size and format in a pre-processing step.

After the analysis is done, the database obtained is divided into two types. The first type is a very small text file with only a handful of values that describe a few things of the image. This file is useful to sort all images based on some or all of these values. The second type is a semi-structured \gls{json} file that includes a lot of data referring to each image. This second file is then used for a set of purposes. On the one hand, we can use this database to perform queries based on those values and obtain desired images. For example, we can ask for bright images, or images with faces or bodies, or images with lots of blobs, etc. On the other, from this database we obtain a set of color words (English color names) of the most present colors on each image. These color words become the link between image and audio in a process that goes as follows. First, we use these color words to query related nouns to those colors using an online database called Datamuse.com. Then, from this query, we obtain another database that has all of these colors and nouns. Finally, this intermediary database that has only text is used to query Freesound.org, to match and download sounds related to those words. Once we have our folder with downloaded audio files from Freesound, we concatenate all of these sounds in sound files named with their respective color words.

Now we can use our audio and image databases to perform a simultaneous query to both, and display this live as an audio/visual stream. The live query is made with a matching matrix that equates certain image descriptors with some audio descriptors. For example, images with faces and bodies will match with audios with pitches on them, and images with many blobs will match with noisier sounds.


\img{dataflow}{1}{
  Data flow needed to obtain a live querying system for images and audio based on feature equivalencies.
}{Diagram representing each step}

\section*{Steps}

The program is broken down into independent modules that enable you to perform a sequence of tasks that are needed for the live querying system to work. While these steps may be done systematically with an automated script, I chose to keep each module separated by design, so as to provide fine tuning on each part of the process. In this sense, you can better adjust parameters in each step of the way according to the particular datasets that you would use. Most of these steps are run from the command line and they take several arguments. See their help for further information on how to use them. Nonetheless, some of these programs are Pure Data patches run on batch mode, meaning that you can open the respective patches to edit or to change internal parameters according to your needs. 

These are the main steps:

\begin{enumerate}
  \singlespacing
  \item Download
  \item Preprocess
  \item Analyze Images
  \item Sorter
  \item Color Sounds
  \item Analyze Sounds
  \item Live Query
\end{enumerate}

\subsection*{1. Download}

The way this system works is that you must start with a folder with images that you then preprocess and analyze for useful descriptions. Later versions of this program will enable you to start with a folder with audio instead. For now, you need to first download an image dataset of raw, original files into the \texttt{raw} directory. This dataset can be of any type, format, and sizes. In this sense, this directory can contain various images from different sources, either from the web, or made by you.

\subsection*{2. Preprocess}

The program \texttt{preprocess.sh} preprocesses a directory holding an image/video dataset and outputs the following into three directories:

\begin{itemize}
  \singlespacing
\item <img> : resized images to defined \texttt{WIDTH}, \texttt{FORMAT}, base name, and \texttt{EXT}ension
\item <vid> : extracted frames resized to defined \texttt{WIDTH}, base name, and \texttt{EXT}ension
\item <aud> : extracted audio to defined format in \texttt{AUDEXT}
\end{itemize}

Additionally, it outputs a \gls{csv} file holding original files and converted files for later use, since filenames would otherwise be lost. This file is useful for making high quality renderings of visual streams with the original images. 

This step needs \href{https://ffmpeg.org/ffmpeg.html}{ffmpeg} and \href{https://ss64.com/osx/sips.html}{sips}


\subsection*{3. Analyze Images}

The program \texttt{analyze.sh} contains a single function \texttt{analyze()}  which takes three arguments:

\begin{enumerate}
\singlespacing
\item files: like multiimage `open' message: path/to/file/base-*.extension
\item target: prefix to name analysis files
\item roi-flag 1/0 to set roi defined in roi text
\end{enumerate}

The core of this program is the Pure Data file \texttt{analyze.pd}, which is run in batch mode, analyzing the specified images, and returning one \gls{json} file per analyzed image. Optionally, you can define a \gls{roi} by opening the \texttt{roi.pd} patch, then adjusting your desired \gls{roi}, and finally setting the \gls{roi} flag to \texttt{1} before running the command line program.

The output of this program is in two types: an entry file (A) and a data file (B)

\subsubsection*{3.A: Entry file} 
This entry file is a plain text file that contains one entry per image file holding the following data:


\begin{table}
\begin{tabular}{ l | l }

Descriptor   & Brief explanation

\tabularnewline
\hline

brightness   & variance of the image histogram

\tabularnewline
\hline

bodies       & number of bodies found (haarcascades)

\tabularnewline
\hline

faces        & number of faces found (haarcascades)

\tabularnewline
\hline

cvblobs      & number of cvblobs found

\tabularnewline
\hline

lines        & number of hough lines found

\tabularnewline
\hline

circles      & number of hough circles found

\tabularnewline
\hline

keypoints    & number of keypoints (corners) found


\end{tabular}
\end{table}


\subsubsection*{3.B: Data files}

These files are \gls{json} files containing one object per image file holding the actual data. This data is structured as follows:

\begin{table}
\begin{tabular}{ l | p{3cm} |   p{2.5cm} }

Descriptor & Brief explanation & Structure

\tabularnewline
\hline

\texttt{mean\_col}  & the array of color clusters of the image \
& 
\tabitem \texttt{pct} (percentage over the total image) \\
\tabitem \texttt{b} (blue) \\
\tabitem \texttt{g} (green) \\
\tabitem \texttt{r} (red)

\tabularnewline
\hline

\texttt{histo}      & the histogram of the image \
& array of fixed size (64)

\tabularnewline
\hline

\texttt{bodies}     & the sequence of blob information pertaining to found bodies on screen \
& 
\tabitem \texttt{x} \\
\tabitem \texttt{y} \\
\tabitem \texttt{r} (radius) \\
\tabitem \texttt{id} 

\tabularnewline
\hline

\texttt{faces}      & the sequence of blob information pertaining to found faces on screen \
& (same as \texttt{bodies})

\tabularnewline
\hline

\texttt{blobcount}  & the number of blobs detected \
& one value

\tabularnewline
\hline

\texttt{blobpoints} & the total number of points accross all blobs \
& one value

\tabularnewline
\hline

\texttt{cvblobs}    & the array of blobs recognized in the image \ 
& 
\tabitem \texttt{Ycentroid} \\
\tabitem \texttt{Xcentroid} \\
\tabitem \texttt{length} \\
\tabitem \texttt{points} \\
\tabitem \texttt{corners} (4 x-y pairs) \\
\tabitem \texttt{area} \\
\tabitem \texttt{angle} \\
\tabitem \texttt{Ysize} \\
\tabitem \texttt{Xsize} \\
\tabitem \texttt{Ycenter} \\
\tabitem \texttt{Xcenter} \\
\tabitem \texttt{id} \\

\tabularnewline
\hline

\texttt{lines}      & the array of lines found on the image \
& 
\tabitem \texttt{r} (length) \\
\tabitem \texttt{y} \\
\tabitem \texttt{x} \\
\tabitem \texttt{id}

\tabularnewline
\hline

\texttt{circles}    & the array of circles found on the image \
& (same as \texttt{lines})

\tabularnewline
\hline

\texttt{keypoints}  & the array of keypoints (corners) found on the image \
& 
\tabitem \texttt{y} \\
\tabitem \texttt{x} \\
\tabitem \texttt{id}


\end{tabular}
\end{table}



\subsection*{4. Sorter}

The program \texttt{sorter.sh} has only one function named \texttt{sort\_it()}, which takes a variable number of arguments. The arguments are the field (columns) of a given text file with which to sort the text file. Thus, it enables you to sort the entries file (A) based on any given field, as well as with pairs or sets of fields. It outputs the sorted files into a file with the same name of the original, appended with the \texttt{-sorted.txt} flag to the name. Each line of the \texttt{-sorted.txt} file contains the sorted indices of each image filename. This is useful to load within Pure Data as a text file for use with the live querying system, as an alternative way to generate image sequences besides the query results.



\subsection*{5. Color Sounds}

The purpose of this section is to obtain a sound database based on the analyzed images. It uses the color clusters for this purpose. Since it is a rather large process, this section is broken down in three steps:


\subsubsection*{5.1. Get color words}

\texttt{python\ src/colors.py}

First, this script places all data objects (B) inside an array of objects in one \gls{json} object (C) (Concatenates \gls{json} files into one)

This script gets English names of the clustered colors in the \gls{json} data base (C), and outputs a file \texttt{./data/colorwords.json} containing one entry per unique color. The structure is like this: \texttt{name}, \texttt{idlist}, and \texttt{words}.

\begin{table}
\begin{tabular}{l | l}

Key     & Value

\tabularnewline
\hline


name    & English name of the color, e.g. `blue'

\tabularnewline
\hline

idlist  & all the image ids that have that color

\tabularnewline
\hline

words   & nouns related to such color after querying Datamuse, e.g. `sky,' `eyes,' etc.\footnote{\url{https://datamuse.com}} 

\end{tabular}
\end{table}


\subsubsection*{5.2. Get color sounds:}

The file \texttt{./data/colorwords.json} is then used to query \href{https://freesound.org}{Freesound} and download sounds related to all \texttt{words} and \texttt{name}s using:

\texttt{python\ src/fs\_download.oy}

NOTE: some colors may not result in words that have a related sound to them.


\subsubsection*{5.3. Concatenate sounds:}

Concatenate color sounds into same files and name the file with the image id:

\texttt{python\ src/concat\_sounds.py}

This script runs \texttt{ffprobe} to ignore files that might not be audio, or that might be malformed. It then runs \texttt{ffmpeg} to concatenate all the audio related to a color name into a file named with that same color name.




\subsection*{6. Analyze Sounds}

\texttt{sh\ analyze\_sounds.sh}

This script runs the \texttt{analyze\_sounds.pd} file in batch mode. It analyzes sounds in a given directory, and places all \texttt{*.timid} files in a second directory. Optionally, you can analyze only one file by index into the directory with a 3rd argument.

By default, the analysis is outputted both in \texttt{*.timid} and in \texttt{*.json} (using \texttt{timid2json.py}), and it concatenates all \gls{json} files into one database.


\paragraph{Instance Structure}

The first nine features are single-valued, so one float each. The last two features default to 50 values each, representing the bins of the bark scale with a filterbank spaced at 0.5. You can edit this and other parameters on the parameters file (open \texttt{analyze\_sounds.pd} to do this). The instance length would change accordingly. The output analysis file is one per each audio file, with the following instance structure:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
  \singlespacing
  \singlespacing
\tightlist
\item
  barkSpecSlope
\item
  barkSpecKurtosis
\item
  barkSpecSkewness
\item
  barkSpecBrightness
\item
  barkSpecFlatness
\item
  barkSpecRolloff
\item
  barkSpecCentroid
\item
  barkSpecSpread
\item
  barkSpecIrregularity
\item
  bfcc
\item
  barkSpec (used for all of the above, internal window size is 512)
\end{enumerate}

(see help files for \href{https://github.com/wbrent/timbreID}{timbreID})

The default analysis window size is 4096, so in one second of file at 44100, you will have around 10 instances, which is ok for many purposes, but you can change this. On the one hand, you can specify overlaps (default 1, no overlap). On the other, you can define an analysis average factor \textbf{f} (default 8). This factor is used to average several smaller sized analysis into one. To do this, we simply take the mean of \textbf{f} consecutive analysis frames within the larger analysis window size.



\subsection*{7. Live Query}

This enables you to perform live queries to both images and audio simultaneously, using the same query parameters and a matching matrix.


\paragraph{Instructions to open this patch:}

Run on three separate terminals:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
  \singlespacing
\tightlist
\item
  \texttt{sh\ audio} (for the sounds)
\item
  \texttt{sh\ display} (for the images)
\item
  Run the live database: \texttt{python\ src/live\_query.py\ ./txt/images-entries.txt\ ./data/images-data.json\ ./data/audio-data.json\ ./data/colorwords.json\ 5011\ localhost}
\item
  Now open \texttt{live\_query.pd}
\end{enumerate}


\paragraph{Matching matrix}

\begin{longtable}[]{@{}ll@{}}
\toprule
Image Feature & Audio Feature\tabularnewline
\midrule
\endhead
thres\_\{R,G,B\} & audio database\tabularnewline
thres\_C & audio database\tabularnewline
\{bodies, faces\} & Kurtosis\tabularnewline
\{bodies, faces\}{[}size{]} & Skewness\tabularnewline
brightness & Slope\tabularnewline
smoothness* & grain size (for concatenation)\tabularnewline
cutness* & grain size (for concatenation)\tabularnewline
blobiness & Brightness, Flatness, Rolloff\tabularnewline
skewness* & grain location (for spatialization)\tabularnewline
boundedness & Centroid, Spread\tabularnewline
kontrastedness & Irregularity\tabularnewline
\bottomrule
\end{longtable}

(*) Not used in the audio query


\section*{Extra}


\subsection*{Reader / Visualizer}

\begin{verbatim}
cd bin
pd reader.pd
\end{verbatim}

This patch can be used to visualize the \gls{json} data files (B)




\subsection*{Image Query (non-realtime)}

\begin{verbatim}
cd bin
pd query.pd
\end{verbatim}

NOTE: This patch is a gui for \texttt{src/query.py}.

This patch can be used to:

\begin{itemize}
  \singlespacing
\tightlist
\item
  perform a query to the \gls{json} database (C) to get indices, based on
\item
  multiple descriptors (color, brightness, smoothness, blobiness, etc.),
\item
  visualize the queries for live editing with the \texttt{sh\ display} program
\end{itemize}

Both input query and its results are stored on \gls{json} files for later use.




\section*{Dependencies}


\subsection*{Externals}

I have not included binaries within this repo, but you can download the following externals:

Available via \texttt{deken}:

\begin{itemize}
  \singlespacing
\tightlist
\item
  \obj{Gem}
\item
  \obj{pix\_opencv}
\item
  \obj{purest\_json}
\item
  \obj{ggee}
\item
  \obj{timbreID}
\item
  \obj{zexy/repack}
\end{itemize}

Available via Github at \url{https://github.com/fdch/fd_lib}:

\begin{itemize}
  \singlespacing
\tightlist
\item
  \obj{fd\_lib} for \obj{iterate} and \obj{counter}
\end{itemize}


\subsection*{Abstractions}

In the \texttt{bin/lib} directory there are some abstractions made for this repo (prepended with a \texttt{\_}. I also have included these together with some other abstractions as well in the \texttt{pdbin} directory that are taken from \obj{fd\_lib} and other places. \texttt{pdbin} might not be necessary if you have already installed all the external libraries mentioned above. NOTE: the \texttt{pdbin} directory is not necessary to load the patches, it is just placed there for convenience. Just declare it with \obj{declare\ -path\ ../pdbin} if you need to use it.

