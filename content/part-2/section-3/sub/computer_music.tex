Computer music software is computer music's playground. Composing and programming blend into different forms of play that can be understood by a closer look of the playground's design. A key aspect of software design is delimiting constraints to data structures. The first choice is generally the programming language, after which the database tree unfolds its way up to the leaves. Among these leaves is where computer music programs reside. At this level of `leaves' software users are certainly aware that there is a `tree' in front of them. However, their awareness does not necessarily extend to the branches, trunk, or roots of the tree. There is endless music that can be made with leaves just as it can with paper. However, neither music quantity nor music quality are the point here. My argument is that working with data structures changes how we think and perform music making. I claim that composers using these leaves of computer music software are working indirectly with data structures, and unless they engage with programming, they remain unaware of data structures and their constraints. `Indirectly,' because the twigs and branches connect the leaf to the trunk, but these connections become invisible to the non-programmer composer \textit{by design}. Like a phantom limb of the tree, the database remains invisibly \textit{behind}. In this section, I present different approaches from composers and programmers that show how music concepts change with the presence and performance of the database. By database performance I mean neither the quality of musical output, nor the dexterity of the programming activity. Database performance in music composition is the activity of the databaser: databasing to make music.

\img{comp}{png}{0.2}{
	Diagram of database performance in computer music practices. The database is invisibly behind the computer, within the softwares used to create musical works. 
}

\subsubsection{Hierarchical environments}
\label{computer:sssp}

	\begin{quote}
		One of the most important aspects in the design of any computer system is determining the basic data types and structures to be used\dots we have been guided by our projection of the interaction between the tool which we are developing, and the composer. \parencite[119]{icmc/bbp2372.1978.012}
	\end{quote}

	\paragraph{Reducing cognitive burden}
	In William Buxton's survey of computer music practices \parencite{Bux77:Aco, icmc/bbp2372.1978.012, DBLP:conf/icmc/BuxtonPRB80}, he distinguished between \textit{composing programs} and \textit{computer aided composition}, arguing that they both failed as software, the former on account of their personalization and formalization, and the latter on their lack of interactivity. On his later interdisciplinary venture called \gls{sssp}, he focused on \gls{hci} ---a field in its very early stages in 1978---\footnote{William Buxton is now considered a pioneer in \gls{hci}, and he is now a major figure in the Microsoft Research department.}. Buxton's concern throughout his work on \gls{sssp} was to address the``problems and benefits arising from the use of computers in musical composition'' \parencite[472]{DBLP:conf/icmc/BuxtonFBRSCM78}. His solution to the problems was to reduce the cognitive burden of the composer, who ``should simply not have to memorize a large number of commands, the sequence in which they may be called, or the order in which their arguments must be specified'' \parencite[474]{DBLP:conf/icmc/BuxtonFBRSCM78}. He argued that reducing the amount of information given to composers helped them focus on music making. Therefore, in \gls{sssp}, the composer's action was reduced to four main selection tasks: timbres, pitch-time structure, orchestration, and playback. Timbres were assigned by defining waveforms for the table lookup oscillators, and pitch-time structure consisted on pitches and rhythms on a score-like \gls{gui} program called \gls{scriva} \parencite{youtube/buxton10}. Orchestration consisted in placing the previously chosen timbres on the score, and playback meant running the score or parts of it. With this simple but very concise structure, Buxton delimited the scope of action of the composer.

	\paragraph{A Hierarchical Representation}
	Buxton based his research on differing approaches to composition: Iannis Xenakis's score-as-entity approach in his 1971 \citetitle{Xen92:For} \parencite{Xen92:For}, an unpublished 1975 manuscript by Barry Vercoe at \gls{mit} studio for Experimental Music, where Buxton found a note-by-note approach, and Barry Truax's computer music systems \parencite{Tru73:The} which was located somewhere in between, without providing a solution for ``the problem of dealing with the different structural levels of composition ---from note to score---'' \parencite[120]{icmc/bbp2372.1978.012} \see{computer:balance}. Buxton, however, condensed these different approaches into what he called a ``chunk-by-chunk'' composition, where a `chunk' represented anything from a single note to an entire score, and thus reframed the question of a compositional approach as one of scale. For Buxton, ``the key to allowing this `chunk-by-chunk' addressing lies in our second observation: that the discussion of structural `levels' immediately suggest a hierarchical internal representation of scores'' \parencite[120]{icmc/bbp2372.1978.012}. That is to say, his solution for the scalability problem relied on a hierarchical representation of scores. 

	In Buxton's \gls{sssp}, the hierarchical design depended on a data structure called \textit{symbol table}, which he subsequently divided into two objects called \texttt{score} and \texttt{Mevent} (musical events). The \texttt{score} structure had a series of global fields (variables) together with pointers to the first (head) and last (tail) \texttt{Mevent}s. In turn, \texttt{Mevent}s had local fields for each event together with pointers to the next and previous \texttt{Mevents}, so as to keep an ordered sequence \see{computer:linked} and enable temporal traversing of the tree. In turn, \texttt{Mevents} could have two different types: \texttt{MUSICAL\_NOTE} and \texttt{Mscore}, the former relating to terminal nodes editable by the user ---what he referred to as `leaves' of the tree structure---, and the latter consisting of nested \texttt{score} objects that added recursivity to the structure. Buxton's model was thus hierarchic (a tree structure) implemented in nested and doubly-linked symbol tables.

	\citeauthor{icmc/bbp2372.1978.012} gave a detailed exposition of the data structures and their functionality in their paper \citetitle{icmc/bbp2372.1978.012} \parencite{icmc/bbp2372.1978.012}. Buxton's general purpose in his \gls{hci} philosophy was to make the software work in such a way that it became invisible or transparent to the user. This is also known as a black-box approach. His innovations in this and other projects have had enormous resonances in computer science, and the concept of reducing cognitive burden of the user has developed as a standard of \gls{hci} \parencite{youtube/buxton16}.

	\paragraph{Black-boxing}

	In 1985, media theorist Vílem Flusser \parencite{Flu11:Int} proposed the term `envision' to describe a person's power to visualize beyond the surface of the image, and to bring the technical image into a concrete state of experience. The `image,' in Flusser's case is the television screen in its abstract state of ``electrons in a cathode ray tube.'' Therefore, he argues, ``if we are asking about the power to envision, we must let the black box remain ---cybernetically--- black'' \parencite[35]{Flu11:Int}. By seeing past the abstract quality of media we bring an image into experience. The black box is the possibility condition for envisioning to take place. In a similar way, by seeing past the hidden complexities of the software, composers are able to create music with unrestrained imagination. However, as I have shown before, Hansen makes a divergent point claiming that the virtuality inherent in the body is the creative potential of image \textit{in-formation} \see{embodiment}. 

	Understanding the process of information as the experience of technical images, it follows that virtuality and envisioning can be considered complementary. On one hand, there is the technical device, whose multidimensionality is as complex as it is hidden from the envisioner. On the other, the human body with its capacity to create and embody. Flusser's point is, however, paradoxical: ``The envisioner's superficiality, to which the apparatus has \textit{condemned} him and for which the apparatus has \textit{freed} him, unleashes a wholly unanticipated power of invention'' \im \parencite[37]{Flu11:Int}. Therefore, the black-box is what condemns and frees the envisioner to a state of superficiality. However, Flusser continues, ``envisioners press buttons to inform, in the strictest sense of that word, namely, to make something improbable out of possibilities'' \parencite[37]{Flu11:Int}. In other words, Flusser justifies the invisibility of the technological device in favor of its most useful consequence, that is, its ability to make the user create something ``out of possibilities.'' Composers, therefore, are often given these possibilities to create, at the cost of a restricted creation space.

	\paragraph{Generality and Portability}
	\label{computer:free}

	\begin{quote}
		Music data structures must be general enough so that as many styles of music as possible may be represented. This implies that the data structures (or the application's interface to them) should not enforce a musical model (such as equal temperament) that is inappropriate for the musical task at hand. \parencite[318]{icmc/bbp2372.1987.046}
	\end{quote}

	The \gls{sssp} lasted until 1982 due to lack of funding, and in the mid-1980s its research re-emerged with the work of John Free \parencite{icmc/bbp2372.1987.046}, under Helicon Systems' \gls{camp}. Free's programming philosophy called for generality, portability, and simplicity. Due to \gls{sssp}'s many hardware dependencies, the code had to be completely re-written \parencite{DBLP:conf/icmc/FreeV86}. A crucial aspect of Free's programming concerns was portability \see{portability}, which moved him to create higher levels of software abstractions, so that software continued to live on in newer hardware. Free also developed \gls{scriva}, \gls{sssp}'s \gls{gui} program into extensible data structures for music notation arguing that software had to be general enough so that composers could work in multiple styles. The larger implication in Free's argument is that enforcing musical concepts in data structures limits the style that the program can achieve. Therefore, if the program fails to provide a certain level of generic functionality, the composer's output will be modelled by the data structure. On the one hand, it can be argued that this implication is simultaneously overestimating the agency of the database and underestimating that of the composer. In any case, the database works for the composer by taking care of the more tedious task. The cost of this, nonetheless, is that by working for the composer, the database guides the composer through certain paths while hiding other paths.

	\paragraph{Simplification}
	\label{computer:vanilla}

	Hardware-independence led Free to imagine a general purpose, or \textit{vanilla} synthesizer, with which students in ``a music lab with multiple users on a networked computer system'' \parencite[127]{DBLP:conf/icmc/FreeV88} could seamlessly use the timbre world offered by various synthesizers made by different manufacturers. Free created a database that enabled simulaneous interaction among different types of hardware. The \textit{Music Configuration Database} consisted of an intermediate program between the physical \gls{midi} input devices (such as the Yamaha DX7 or Casio CZ101), and the computers in the network, so that ``rather than have the user tediously specify the \gls{midi} device properties for each synthesizer'' \parencite[133]{DBLP:conf/icmc/FreeV88} (channel management, control mapping, etc), these processes were handled by an intermediary database. Free's approach, in comparison to Buxton's, was not entirely black-boxed, since the database was open to modification by a specific set of commands provided to the user. The user could edit the database with a library of database access subroutines such as open/close, create/delete items, querying fields/keys, and loading/storing property items. With this library, Free simultaneously simplified user's interaction and reduced the ``chance of corrupting the database'' \parencite[137]{DBLP:conf/icmc/FreeV88}. 

	\paragraph{Balance}
	\label{computer:balance}

	\img{truax_generality_b}{png}{0.7}{
		Barry Truax' ``Inverse Relation Between Generality and Strength'' \parencite[51]{Tru80:The}. Another version of this graph can be found in \parencite[38]{laske_otto_1999}.
	}

	\begin{quote}
		\dots all computer music systems both \textit{explicitly and implicitly embody a model of the musical processes that may be inferred from the program and data structure of the system}, and from the behavior of user working with the system. The inference of this model is independent of whether the system designer(s) claim that the system reflects such a model, or is simply a tool. \im \parencite[230-231]{Tru76:ACo}
	\end{quote}

	Barry Truax (\cite{Tru73:The,Tru76:ACo, Tru80:The}, \cite[Chapter~8]{Emm86:The}), often compared grammatical structures of natural language to the structures of computer music systems, claiming that in both cases one can find certain constraints and facilitations for thought \parencite[156]{Emm86:The}. Arguing for balance between generality of applicability and strength of embedded knowledge within models for computer music systems \fsee{truax_generality_b}, he writes:

	\begin{quote}
		In a computer music system, the grouping of data into larger units such as a sound-object, event, gesture, distribution, texture, or layer may have a profound effect on the composer's process of organization. The challenge for the software designer is how to provide powerful controls for such interrelated sets of data, how to make intelligent correlations between parameters, and how to make such data groupings \textit{flexible according to context}. \im \parencite[157]{Emm86:The}
	\end{quote}

	Truax's notion of balance speaks of a `meeting halfway' between the system and the user regarding the programmer's capability to embed a more complex conception of hierarchy in the system. What provides this balance is a certain flexibility among data structuresm which would enable them to adapt to the different hierarchical contexts with which music is understood. That is to say, since data structures can embody models of musical processes, they have an effect on the composer's overall performance of the database, and by extension, on the resulting music. 

\subsubsection{Enter Objects}

\img{realtime}{png}{0.9}{
	A bodyless abstract published at the \gls{icmc} (1981) stating that a real-time version of MUSIC-11 was ``near completion'' by a group at MIT \parencite{DBLP:conf/icmc/PucketteVS81}.
}

	\paragraph{Max and data structures for real-time}
	\label{computer:real-time}

	Faster, cheaper, and portable microcomputers with real-time capabilities for audio processing began to appear onstage within institutions such as \gls{mit}, \gls{ircam}, among others, and a growing interest among composers and programmers circled around real-time computer music software \fsee{realtime}. Towards the end of the 1980s, after the proliferation of \gls{midi} \parencite{Loy85:Mus}, composers were already incorporating real-time techniques within musical instruments and software \parencite{Puc91:Som}. This is the context for Miller Puckette's development of \gls{max} for the 4X real-time audio processor at \gls{ircam} \parencite{DBLP:conf/icmc/Puckette86}. With an emphasis was on time and scheduling, Puckette devised a new approach towards complexity in computer music software:

	\begin{quote}
		\dots complexity must never appear in the dealings between objects, only within them. Three other features currently in vogue seem unnecessary. First, there is no point in having a built-in notion of hierarchy; it is usually a hindrance. Second, I would drop the idea of continuously-running processes; they create overhead and anything they do can be done better through [input, output] related timing. Third, there should be few defaults. Rather than hide complexity I would keep it visible as an incentive to avoid it altogether. \parencite[43]{DBLP:conf/icmc/Puckette86}
	\end{quote}

	Puckette keeps complexity ``visible'' within the concept of the programming \textit{object}. Furthermore, he removes the notion of hierarchical programming which was also present in Buxton's view, and proposes a light-weight, on-the-spot programming practice based on discontinuous processes. The structure of the database was placed \textit{horizontally}, that is, along the time axis, and Puckette's efforts were dedicated to optimizing the internal timing of the processes.\footnote{The scheduler keeps the runnable-message pool in the form of a separate queue for each latency. The scheduler always sends the first message in the lowest-latency nonempty queue. When the associated method returns the scheduler sends another message and so on. The only situation in which we need to interrupt a method before it is done is when I/O (including the clock) causes a lower-latency message to appear\dots In this case the scheduler causes a software interrupt to occur by pushing a new stack frame onto the stack and executing the lower-latency method. When this method returns \dots we pop the stack back to the prior frame at latency \(d_2\) and resume the associated method. \parencite[46]{DBLP:conf/icmc/Puckette86}} Specifically, linked lists are used to keep track of the order of processes that are run, and each process is scheduled according to its own temporality (latency). Thus, the entire network of processes that can be run is maintained in a dynamic list (stack) that can be changed at any time by adding or removing elements (push/pop). The way in which these processes (methods) are called is by messages that can be sent (input/output) by the user or objects themselves. In sum, the object-oriented paradigm which was already in use in the \gls{music-n} programs was, in this case, applied to the scheduling system, resulting in a ground-breaking implementation that changed the real-time computer music performance scene: ``\dots rather than a programming environment, \gls{max} is fundamentally a system for scheduling real-time tasks and managing intercommunication between them'' \parencite{DBLP:journals/comj/Puckette02}.

	\paragraph{Pure Data}
	\label{computer:puredata}

	Because of this emphasis on process, when Puckette developed Pure Data \parencite{icmc/bbp2372.1997.060}, he made it so data structures were a more accessible feature for the user to define and edit. To this day this Max paradigm \parencite{DBLP:journals/comj/Puckette02} can still be found in both widely used programs \gls{max/msp} \parencite{DBLP:conf/icmc/Zicarelli98} and Pure Data. In this paradigm, Puckette pushes data structure flexibility as a means to provide a musical instrument without stylistic constraints:

	\begin{quote}
		The design of \gls{max} goes to great lengths to avoid imposing a stylistic bias on the musician's output. To return to the piano analogy, although pianos might impose constraints on the composer or pianist, a wide variety of styles can be expressed through it. To the musician, the piano is a vehicle of empowerment, not constraint. \parencite{DBLP:journals/comj/Puckette02}
	\end{quote}

	Puckette, therefore, aims to a certain stylistic neutrality, which he represents by the way in which the user opens the program: a blank page: ``no staves, time or key signatures, not even a notion of 'note,' and certainly none of instrumental 'voice' or 'sequence''' \parencite{DBLP:journals/comj/Puckette02}. While acknowledging that even the 'blank page' is a culturally loaded symbol referring to the use of paper in Western Art Music (much in the same way that it is favoring complexity in the above described design), Puckette reconfigured computer music design, composition, and performance by considering the way in which the structure of the program resonates aesthetically.

	\paragraph{Data structures for graphic scores}
	\label{computer:datastructures}


% Basing his research on the \gls{sssp} project's philosophy (and in reaction to it),
	Puckette also implemented a feature within Pure Data to enable the creation of graphic scores for electronic music \parencite{DBLP:conf/icmc/Puckette02}. In order to do this, he contextualized his research with the \gls{sssp} original project to include graphic scores within the composition environment, the \textit{Animal} project by Lindemann and de Cecco which allowed users to ``graphically draw pictures which define complex data objects'' \parencite{DBLP:conf/icmc/Lindemann90a}, and three other cases of graphic scores used to model electroacoustic music: Stockhausen, Yuasa, and Xenakis. Puckette's data structures derive from those of the C programming language, and they can be used in relation to any type of data. 
% rewrite
	Following his notion of neutrality within musical style, he resolved in avoiding graphic predeterminations, namely, the fact that the $x$-value within the graphical canvas is left unlinked with time, without intervening in the user's conception of time. 

	Despite this significant programming decision, Puckette provided the user with a sorting function, ``on the assumption that users might often want to use Pd data collections as x-ordered sequences'' \parencite{DBLP:conf/icmc/Puckette02}.

	\paragraph{RtCMIX and the heap}
	\label{computer:rtcmix}

% Again, we leave the specific history you were telling to list things. you need to say why you are doing this, don’t just start listing.


	In the same \gls{icmc} conference of 1997, two object-oriented languages were presented. Brad Garton and David Topper presented \gls{rtcmix} \parencite{DBLP:conf/icmc/GartonT97}, a real-time version of the \gls{cmix} program by Paul Lansky. What they described as innovative in this project is, in a similar way to the data structures for time management that Puckette presented, the scheduling capabilities of the program. In contrast to the \gls{cmix} language, which assumes a non-real-time access of objects, the

	\begin{quote}
		RTcmix event scheduling is accomplished through a binary tree, priority-queue dynamic heap\dots\footnote{A heap is a tree-based data structure with a property such keys and parent-child relationships follow a hierarchic logic.} The heap is also designed to do ``scheduling-on-the-fly,'' allowing notes to be scheduled at run-time (usually triggered by an external event, such as a \gls{midi} note being depressed). \parencite{DBLP:conf/icmc/GartonT97}
	\end{quote}

	What this means, virtually, is that the real-time problem became a scheduling problem of computing tasks. However, in the case of RtCMIX, the instruments that are instantiated ``on-the-fly'' can also establish their own \gls{tcp/ip} connection sockets in order to allow for networked access to the individual synthesizers \parencite{DBLP:conf/icmc/GartonT97}.

	\paragraph{OpenMusic}
	\label{computer:openmusic}

	Another object-oriented language was a visual programming environment for non-real-time composition called OpenMusic \parencite{DBLP:conf/icmc/AssayagAFH97}. While not a synthesis engine, the strength of this Lisp-based graphic language developed as a collaboration at IRCAM, resides in its ability to provide the composer access to a variety of sound analysis tools for composition \parencite{icmc/bbp2372.2004.004, icmc/bbp2372.2010.129}, as well as the possibility to generate algorithmic streams that output directly into a traditionally notated score. For example, OpenMusic introduced the concept of a \textit{maquette}, which is a graphic canvas upon which a heterogenous set of elements as varied as audio waveforms, scores, or piano-roll type notation can be displayed.

	\paragraph{Kyma}
	\label{computer:kyma}

	Another powerful example of an object-oriented language for music composition is Kyma \parencite{DBLP:conf/icmc/Scaletti87}. It was developed by Carla Scaletti at \gls{cerl} in 1987, as an interactive non-real-time composition environment for the Platypus digital signal processor. Scaletti's language was hierarchical in its structure which, as I have described above, enabled the data records to be linked, that is, to be grouped vertically and horizontally. These data structures formed together objects, enabling the composer to treat as objects any set of sounds within the composition, starting from the composition itself as an object. In such a way: ``\dots the composer could create a `sound universe,' endow the sound objects in this universe with certain properties and relationships, and explore this universe in a logically consistent way'' \parencite[50]{DBLP:conf/icmc/Scaletti87}'' Therefore, and given the ``vast amounts of data required for sound synthesis'' \parencite[50]{DBLP:conf/icmc/Scaletti87}, the overall concept of Kyma was to fit the conjunction of timbre creation and temporal event lists into the same traversable database that the program proposed. What is important, however, is Scaletti's intention. In much the same way as Puckette, for Scaletti ``the language itself would not impose notational or stylistic preconceptions'' \parencite[50]{DBLP:conf/icmc/Scaletti87}.

	\paragraph{Cypher}
	\label{computer:cypher}

	\citeauthor{Row92:Int}'s interactive music system \textit{Cypher} is an object-oriented program aimed at machine listening and composition in real-time \parencite{Row92:Int}. It is constituted by two \gls{midi}-based interconnected agents, a \textit{listener} and a \textit{player}. The player outputs musical material that results from generative or transforming processes on the (machine) listened input. The listener interprets incoming streams of \gls{midi} data with \gls{mir} techniques (central pitch detection, beat tracking, among others) grouping \texttt{Note}s into larger \texttt{Event}s, and then into larger musical phrases. Both \texttt{Note} and \texttt{Event} are objects with specific data structure: the former closely linked to the \gls{midi} message, the latter forming a circular linked list that enables traversing between neighbouring \texttt{Event}s. Attached to these \texttt{Event}s, however, reside intermediary agents that each store musical information that is locally relevant to the parent \texttt{Event}. The attached information, therefore, is fundamental to the system: ``The feature space representation \dots tends to treat parameters of the sound-pressure waves carrying musical percepts as central. Register, loudness, and density are all primary components of the representation'' \parencite[Chapter~7]{Row92:Int}. This constitutes Rowe's implementation of the object-oriented model. Upon deciding which analytical model to apply to the \textit{listener} agent, however, Rowe finds a coexistence of two virtually opposing models for music analysis: a hierarchical one (Shenker, Forte, Lerdahl) and a networked one (Narmour). While extending an analysis of database models to music theory is beyond the scope of this study, it is interesting to note how the versatility of the object model can integrate two very different ways of thinking musical relationships: ``Cypher's listener and player are organized hierarchically, though these hierarchies tend toward Narmour's network ideas rather than the more strictly structured trees of Lerdahl and Jackendoff'' \parencite[Chapter~4.3]{Row92:Int}. 

	\paragraph{SuperCollider and nodes}
	\label{computer:supercollider}

	The literature on computer music software for composition alone would extend beyond the scope of this dissertation. However, there are important features to acknowledge from yet another object-oriented language for music synthesis that was developed at the end of the 1990s, namely, James McCarntney's SuperCollider \parencite{DBLP:conf/icmc/McCartney96, DBLP:conf/icmc/McCartney98}. This high-level language provides the user with a different paradigm to handle audio processes, their ordering, and ---most importantly--- their switching. The innovation that this language implemented is the ``garbage collection'' of each process. McCartney took the hierarchic structure of the object-oriented paradigm and defined `nodes' in a tree-like structure, each with its own capability of nesting groups of other nodes, but most importantly, with its own initial and expiration times. In other words, in contrast to the constantly running audio processes that Pure Data and \gls{max/msp}, SuperCollider only consumes \gls{cpu} resources whenever it needs to. This economy of resources that is enabled by the data structure of the language, together with its high-level quality, make it quite remarkable.

	For further reference in other sound synthesis data structures, see: the Diphone synthesis program \parencite{DBLP:conf/icmc/RodetDP88, Rodet1989, DBLP:conf/icmc/DepalleRGE93, DBLP:conf/icmc/RodetL96, DBLP:conf/icmc/RodetL97}; FORMES \parencite{DBLP:conf/icmc/BoyntonDPR86}; the Otkinshi system \parencite{icmc/bbp2372.2002.039}. For an overview of existing audio software up to 2004, see Xamat's PhD Dissertation \parencite[Chapter~2]{Amatriain/2004/phdthesis}. See also the Integra project \parencite{Bullock2009,Bullock2011}, Ariza's work on python's data structures \parencite{Ari05:Ano}, and Rowe's \parencite{Row92:Int, Row01:Mac}