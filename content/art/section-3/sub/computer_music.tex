Delimiting constraints to data structures is one of the key aspects of software design. The first choice is generally the programming language, after which the database tree unfolds its way up to the leaves. Among these leaves is where computer music programs reside. At this level of `leaves' software users are certainly aware that there is a `tree' in front of them. However, their awareness does not necessarily extend to the branches, trunk, or the roots of the tree. There is endless music that can be made with leaves just as it can with paper. However, neither music quanitity nor music quality are the point here. My argument is that working with data structures changes how we think and perform music making. I claim that composers using these leaves of computer music software are working indirectly with data structures, and unless they engage with programming, they remain unaware of data structures and their constraints. `Indirectly,' because there exist the twigs and the branches that connect the leaf to the trunk. These links become invisible to the non-programmer composer \textit{by design}. Like a phantom limb of the tree, the database remains invibibly \textit{behind}. Therefore, in this section I present ideas from composers and programmers that show different approaches on how music concepts change with the presence of the database. 

\img{comp}{png}{0.2}{
	Diagram of database performance in computer music practices. The database is invisibly behind the computer, within the softwares used for (and as) music works. 
}

\subsubsection{Hierarchical environments}

	\paragraph{Reducing cognitive burden}
	\label{computer:sssp}

	\begin{quote}
		One of the most important aspects in the design of any computer system is determining the basic data types and structures to be used\dots we have been guided by our projection of the interaction between the tool which we are developing, and the composer. \parencite[119]{icmc/bbp2372.1978.012}
	\end{quote}

	In William Buxton's survey of computer music practices \parencite{Bux77:Aco, icmc/bbp2372.1978.012, DBLP:conf/icmc/BuxtonPRB80}, he distinguished between \textit{composing programs} and \textit{computer aided composition}, arguing that they both failed as software, the former on account of their personalization and formalization, and the latter on their lack of interactivity. On his later interdisciplinary venture called \gls{sssp}, he focused on \gls{hci} ---a field in its very early stages in 1978---\footnote{William Buxton is now considered a pioneer in \gls{hci}, and he is now a major figure in the Microsoft Research department.}. Buxton's concern throughout \gls{sssp} was to address the``problems and benefits arising from the use of computers in musical composition'' \parencite[472]{DBLP:conf/icmc/BuxtonFBRSCM78}. His solution was to reduce the cognitive burden of the composer, who ``should simply not have to memorize a large number of commands, the sequence in which they may be called, or the order in which their arguments must be specified'' \parencite[474]{DBLP:conf/icmc/BuxtonFBRSCM78}. He argued that reducing the amount of information given to composers helped them focus on music making. Therefore, in \gls{sssp}, the composer's action was reduced to four main selection tasks: timbres, pitch-time structure, orchestration, and playback. Timbres were assigned by defining waveforms for the table lookup oscillators, and pitch-time structure consisted on pitches and rhythms on a score-like \gls{gui} program called \gls{scriva} \parencite{youtube/buxton10}. Orchestration consisted in placing the previously chosen timbres on the score, and playback meant running the score or parts of it. With this simple but very concise structure, Buxton delimited the scope of action of the composer.

	\paragraph{A Hierarchical Representation}

	Buxton based his research on differing approaches to composition: Iannis Xenakis's score-as-entity approach \parencite{Xen92:For} (the 1971 publication of \citetitle{Xen92:For}), an unpublished 1975 manuscript by Barry Vercoe at \gls{mit} studio for Experimental Music, where Buxton found a note-by-note approach, and Barry Truax's computer music systems \parencite{Tru73:The} which was located somewhere in between, without providing a solution for ``the problem of dealing with the different structural levels of composition ---from note to score---'' \parencite[120]{icmc/bbp2372.1978.012} \see{computer:balance}. Buxton, however, condensed these different approaches into what he called a ``chunk-by-chunk'' composition, where `chunk' represented anything from notes to entire scores, and thus it became a scalability issue. Furthermore, he writes, ``the key to allowing this `chunk-by-chunk' addressing lies in our second observation: that the discussion of structural `levels' immediately suggest a hierarchical internal representation of scores'' \parencite[120]{icmc/bbp2372.1978.012}. That is to say, his solution for the scalability problem came with a hierarchical representation of scores. 

	In Buxton's \gls{sssp}, the hierarchical design depended on a data structure called \textit{symbol table}, which he subsequently divided in two objects called \texttt{score} and \texttt{Mevent} (musical events). The \texttt{score} structure had a series of global fields (variables) together with pointers to the first (head) and last (tail) \texttt{Mevent}s. In turn, \texttt{Mevent}s had local fields for each event together with pointers to the next and previous \texttt{Mevents}, so as to keep an ordered sequence \see{computer:linked} and enable temporal traversing of the tree. In turn, \texttt{Mevents} could have two different types: \texttt{MUSICAL\_NOTE} and \texttt{Mscore}, the former relating to terminal nodes editable by the user ---what he referred to as `leaves' of the tree structure---, and the latter consisting of nested \texttt{score} objects that added recursivity to the structure. Buxton's model was thus hierarchic (a tree structure) implemented in nested and doubly-linked symbol tables.

	\citeauthor{icmc/bbp2372.1978.012} gave a detailed exposition of the data structures and their functionality in the paper \parencite{icmc/bbp2372.1978.012} \citetitle{icmc/bbp2372.1978.012}. In light of this transparency (and, perhaps, because of it), however, Buxton's general purpose in his \gls{hci} philosophy is to make the software work in such a way that it becomes invisible to the user. This is also known as a black-box approach. His innovations in this and other projects, however, have had enormous resonances in computer science, and the concept of reducing cognitive burden of the user developed as a standard of \gls{hci} \parencite{youtube/buxton16}.

	\paragraph{Black-boxing}

	VÃ­lem Flusser \parencite{Flu11:Int} described our ability to envision as the power to visualize beyond the surface of the image, and to bring the technical image into a concrete state of experience. The `image,' in Flusser's case is the television screen in its abstract state of ``electrons in a cathode ray tube.'' Therefore, he argues, ``if we are asking about the power to envision, we must let the black box remain ---cybernetically--- black'' \parencite[35]{Flu11:Int}. By seeing past the abstract quality of media we bring an image into experience. The black box is the possibility condition for envisioning to take place. Thus, by seeing past the hidden complexities of the software, composers are able to create music with unrestrained imagination. However, as I have shown before, Hansen makes a divergent point claiming that virtuality inherent in the body is the creative potential of image in-formation \see{embodiment}. 

	Understanding the process of information as the experience of technical images, it follows that virtuality and envisioning can be considered complementary. On one hand, there is the technical device, whose multidimensionality is as complex as it is hidden from the envisioner. On the other, the human body with its capacity to create and embody. Flusser's point is, however, paradoxical: ``The envisioner's superficiality, to which the apparatus has \textit{condemned} him and for which the apparatus has \textit{freed} him, unleashes a wholly unanticipated power of invention'' \im \parencite[37]{Flu11:Int}. Therefore, the black-box is what condemns and frees the envisioner to a state of superficiality. However, Flusser continues, ``envisioners press buttons to inform, in the strictest sense of that word, namely, to make something improbable out of possibilities'' \parencite[37]{Flu11:Int}. In other words, Flusser's text in 1985 justifies the invisibility of the technological device in favor of its most useful consequence, that is, its ability to make the user create something ``out of possibilities.'' Composers, therefore, are given these possibilities to create, at the cost of a limited performance of the database.

	\paragraph{Generality and Portability}
	\label{computer:free}

	\begin{quote}
		Music data structures must be general enough so that as many styles of music as possible may be represented. This implies that the data structures (or the application's interface to them) should not enforce a musical model (such as equal temperament) that is inappropriate for the musical task at hand. \parencite[318]{icmc/bbp2372.1987.046}
	\end{quote}

	The \gls{sssp} lasted until 1982 due to lack of funding, and in the mid-1980s its research re-emerged with John Free \parencite{icmc/bbp2372.1987.046}, under Helicon Systems' \gls{camp}. Free's programming philosophy thus called for generality, portability, and simplicity. Due to \gls{sssp}'s many hardware dependencies, the code had to be completely re-written \parencite{DBLP:conf/icmc/FreeV86}. Hardware development would demand higher levels of software abstractions, so that software continued to live on in newer hardware. This issue refers to the portability of software \see{portability}, which became a crucial aspect of Free's programming concerns. Besides portability, Free developed \gls{scriva} into extensible data structures for music notation arguing for  generality. Software had to be general enough so that composers could work in multiple styles. The larger implication in the Free's argument is that enforcing musical concepts in data structures limits the style that the program can achieve. Therefore, if the program fails to provide a certain level of generic functionality, the composer's output will be modelled by the data structure. On the one hand, it can be argued that this implication is, simultaneously overestimating the agency of the database, and underestimating that of the composer. However, the programming philosophy here is that of reducing the burden of the user by taking care of the more tedious task. The cost of this, nonetheless, is that by working for the composer, the database guides and hides: it guides the composer through certain paths and hides the composer from other paths. That is to say, if composers take the paths given by the database as givens, then those become the only possible paths.

	\paragraph{Simplification}
	\label{computer:vanilla}

	Hardware-independence led Free to also imagine a \textit{vanilla} synthesizer, with which students in ``a music lab with multiple users on a networked computer system'' \parencite[127]{DBLP:conf/icmc/FreeV88} could seamlessly use the timbre world offered by various synthesizers made by different manufacturers. Software needed to interact simultaneously with different types of hardware. Free achieved this type of interaction with the \textit{Music Configuration Database}. It consisted of an intermediate program between the physical \gls{midi} input devices (such as the Yamaha DX7 or Casio CZ101), and the computers in the network, so that ``rather than have the user tediously specify the \gls{midi} device properties for each synthesizer'' \parencite[133]{DBLP:conf/icmc/FreeV88} (channel management, control mapping, etc), these processes were handled by an intermediary database. Free's approach, in comparison to Buxton's, is not entirely black-boxed, since the database is open to modification by a specific set of commands provided to the user. The user can edit the database with a library of database access subroutines such as open/close, create/delete items, querying fields/keys, and loading/storing property items. With this library, Free simultaneously simplified user's interaction and reduced the ``chance of corrupting the database'' \parencite[137]{DBLP:conf/icmc/FreeV88}. 

	\paragraph{Balance}
	\label{computer:balance}

	\img{truax_generality_b}{png}{0.7}{
		Barry Truax' ``Inverse Relation Between Generality and Strength'' \parencite[51]{Tru80:The}. Another version of this graph can be found in \parencite[38]{laske_otto_1999}.
	}

	\begin{quote}
		\dots all computer music systems both \textit{explicitly and implicitly embody a model of the musical processes that may be inferred from the program and data structure of the system}, and from the behavior of user working with the system. The inference of this model is independent of whether the system designer(s) claim that the system reflects such a model, or is simply a tool. \im \parencite[230-231]{Tru76:ACo}
	\end{quote}

	Barry Truax (\cite{Tru73:The,Tru76:ACo, Tru80:The}, \cite[Chapter~8]{Emm86:The}), often compared grammatical structures of natural language to the structures of computer music systems, claiming that in both cases one can find certain constraints and facilitations for thought \parencite[156]{Emm86:The}. Arguing for balance between generality of applicability and strength of embedded knowledge within models for computer music systems \fsee{truax_generality_b}, he writes:

	\begin{quote}
		In a computer music system, the grouping of data into larger units such as a sound-object, event, gesture, distribution, texture, or layer may have a profound effect on the composer's process of organization. The challenge for the software designer is how to provide powerful controls for such interrelated sets of data, how to make intelligent correlations between parameters, and how to make such data groupings \textit{flexible according to context}. \im \parencite[157]{Emm86:The}
	\end{quote}

	Truax's notion of balance speaks of a `meeting halfway' between the system and the user on account of the programmer's capability to embed a more complex conception of hierarchy in the system. Balance refers precisely to flexibility among data structures. Since data structures can embody models of musical processes, they have an effect on the composer's overall \textit{performance} of the database in music composition. By `database performance' I do not mean the quality of musical output, or the dexterity of the composer's programming activity. By database performance I refer to the behavioral activity that comprises the scope and quality of the composer's actions, together with the agency of this behavior within the results. 

\subsubsection{Music Notation Software}

	\paragraph{\gls{darms}}
	\label{computer:notation}

	Other programming approaches for music notation software were developed during the 1980s, specifically using the \gls{darms} notation project. The \gls{darms} project started in 1963 by Stefan Bauer-Mengelberg and it is one of the first programming languages for music engraving \parencite{icmc/bbp2372.1983.002, 10.2307/30204239}. Peter J. Clements \parencite{icmc/bbp2372.1980.020} joined together the \gls{darms} data structures with those used in Max Mathews' synthesis program MUSIC V, in a first attempt to obtain sonic feedback out of a notation system. However, Clements' attempt was not as successful as Leeland Smith's famous \gls{score} \parencite{smith1971}. Smith's program consisted of a character scanner interpreting rhythmically complex musical input into MUSIC V output. Thus, it was an intermediary between music notation and computer music synthesis. With the appearance of vector graphics in the 1970s, however, \gls{score} shifted solely to music printing and later became commercially available with the appearance of the 	PostScript format in the 1980s.\footnote{\gls{score} is one of the earliest music engraving softwares still in use today by major publishing houses \parencite{scoremus}.}

	\paragraph{Computer Scores}
	\label{computer:computer}

	Alexander Brinkman \parencite{icmc/bbp2372.1981.018} modelled Smith's input format into \textit{Score-11}, adapting it to Barry Vercoe's \gls{music-11}. Written in Pascal, \textit{Score-11} used circular linked lists traversed by an interpreter, and it results in \gls{music-11}-formatted output. Thus, the user creates a text file with blocks dedicated to individual instruments, and specifies parameters such as rhythm, pitch, movement (glissandi, crescendo), amplitude, etc., that are then re-formatted to fit the less musically-oriented notation of the \gls{music-n} programs. Brinkman argues that such a software would result in faster and less arduous performance on the composer's end:

	\begin{quote}
		A crescendo over several hundred very short notes requires several hundred different amplitude values representing the increasing volume. \textit{Typing in several hundred note statements each with a slightly larger amplitude number would take forever}. If the computer could be instructed to gradually increase the amplitude value over twenty seconds then \textit{life would be much simpler}. This is the type of job that a note list preprocessor is designed to accomplish. \im \parencite{score11manual}
	\end{quote}

	Brinkman emphasized, as well, on the program's extensibility by users, and it inspired Mikel Kuehn's recent \textit{nGen} program which is a version of Brinkman's program for the currently available Csound \parencite{csoundMethods}. Brinkman, however, designed an interpreter for the \gls{darms} language \parencite{icmc/bbp2372.1983.002}, which became useful for obtaining computable data structures for automated music analysis \parencite{icmc/bbp2372.1984.033}. 

	J. Stephen Dydo \parencite{icmc/bbp2372.1987.045} worked on an interface to the \gls{darms} language called the \textit{Note Processor}, which became one of the earliest commercially available music notation systems. Dydo's data structures, however, were not publicly released when he presented his software at the \gls{icmc} in 1987. He later released it commercially in the early 1990s at a significantly lower price than other notation software, namely \textit{Finale} which is still available today by MakeMusic, Inc. \parencite{10.2307/941442,10.2307/940555}.

	\paragraph{N\textit{u}tation}
	\label{computer:nutation}

	Another approach to music notation was carried out at \gls{ccrma}, when Glendon Diener \parencite{icmc/bbp2372.1988.020, 10.2307/3680043} deviced a ``pure structure'' devoted to the ``hierarchical organization of musical objects into musical scores:'' the \textit{TTree} \parencite[184]{icmc/bbp2372.1988.020}. Stemming from his PhD research on formal languages in music theory \parencite{diener1985}, this data structure was based in the hierarchic structures of the \gls{sssp} project. The change Diener introduced to these structures was their capability of sustaining links between not only the previous and the next data records, but to the `parent' or `child' data records to which it was related. This is known as `inheritance,' and it enabled ``any event in the [structure] to communicate with any other event'' \parencite[188]{icmc/bbp2372.1988.020}.

	While Diener implemented this data structure in the object-oriented programming language \gls{smalltalk}, he later developed it into \textit{Nutation} \parencite{DBLP:conf/icmc/Diener92}, a visual programming environment for music notation. \textit{Nutation} was written in \gls{objective-c}, and it combined the previously developed \textit{TTree} structure with glyphs and a music synthesis toolkit called \textit{Music Kit} that the \gls{next} computer provided. This resulted in an extremely malleable \gls{cac} environment, which enabled fast manipulation and sonic feedback at the cost of limiting timbre to a predefined, hardware-specific set of digital instruments. 

	\paragraph{Theoretical Performance}
	\label{computer:theoretical}

	What notation software is most often criticised for is the way in which sonic feedback often comes to be equiparated to (human) music performance. When Leeland Smith presented \gls{score} as ``not a `performer's' instrument, but rather a `musician's' instrument,'' for example, he claimed that ''theoretically, any performance, clearly conceived in the mind, can be realized on [the computer]'' \parencite[14]{smith1971}. It is indeed a fact that computers can offer automated tasks to an unimaginable extent. However, to translate this type of automation into music composition and performance, results in a disembodied music conception. In other words, an algorithmically generated stream of notes may result in physically impossible tasks for a performer, or for the listener. This is the point of inflexion when envisioning goes beyond the threshold of embodiment. It can be argued, however, that further developments in musical performance techniques can be achieved by pushing the limits of bodily skills. Nonetheless, what I am stressing here is the extent to which music composition can be reconfigured by the possibilities data structures have brought to the field.

\subsubsection{Enter Objects}

	\paragraph{Max and data structures for realtime}
	\label{computer:realtime}

	Composers and programmers in the 1980s began focusing, however, on real-time performance of computer music.\footnote{For example, note a curious paragraph published at the \gls{icmc} in 1981 stating that a real-time version of MUSIC-11 was ``near completion'' by a group at MIT \parencite{DBLP:conf/icmc/PucketteVS81}.} In a joint venture between MIT and IRCAM, the software \gls{max} was being developed by Miller Puckette. Within this software, Puckette's emphasis was on a different aspect of the use of database: time and its scheduling. For example, the main concern in the design of the software is located in the following idea regarding complexity:

	\begin{quote}
		\dots complexity must never appear in the dealings between objects, only within them. Three other features currently in vogue seem unnecessary. First, there is no point in having a built-in notion of hierarchy; it is usually a hindrance. Second, I would drop the idea of continuously-running processes; they create overhead and anything they do can be done better through [input, output] related timing. Third, there should be few defaults. Rather than hide complexity I would keep it visible as an incentive to avoid it altogether. \parencite[43]{DBLP:conf/icmc/Puckette86}
	\end{quote}

	In yet another turn of the screw of Buxton's concept of reducing the user's cognitive burden, Puckette keeps complexity ``visible'' within the concept of the programming \textit{object}. Furthermore, he removes the notion of hierarchical programming which was also present in Buxton's view, and proposes an light-weight, on-the-spot programming practice based on discontinuous processes. The structure of the database was placed \textit{horizontally}, that is, along the time axis, and Puckette's efforts were dedicated to optimizing the handling of the internal timing of the processes:

	\begin{quote}
		The scheduler keeps the runnable-message pool in the form of a separate queue for each latency. The scheduler always sends the first message in the lowest-latency nonempty queue. When the associated method returns the scheduler sends another message and so on. The only situation in which we need to interrupt a method before it is done is when I/O (including the clock) causes a lower-latency message to appear\dots In this case the scheduler causes a software interrupt to occur by pushing a new stack frame onto the stack and executing the lower-latency method. When this method returns \dots we pop the stack back to the prior frame at latency \(d_2\) and resume the associated method. \parencite[46]{DBLP:conf/icmc/Puckette86}
	\end{quote}

	What this means, is that the concept of linked lists is used to keep track of the order of processes that are run, and that each process is scheduled according to its temporality (latency). Thus, the entire network of processes that can be run is maintained in a dynamic list (stack) that can be changed at any time by adding or removing elements (push/pop). The way in which these processes (methods) are called is by messages that can be sent (input/output) by the user or objects themselves. This way of thinking programming in terms of objects is known as object-oriented programming, and it was already in use in the \gls{music-n} programs. However, in this case, the scheduling system that Puckette implemented consisted in a ground-breaking application of the technique that changed the real-time computer music performance scene: ``\dots rather than a programming environment, \gls{max} is fundamentally a system for scheduling real-time tasks and managing intercommunication between them'' \parencite{DBLP:journals/comj/Puckette02}.

	\paragraph{Pure Data}
	\label{computer:puredata}

	Because of this emphasis on process, when Puckette developed Pure Data \parencite{icmc/bbp2372.1997.060}, he made it so data structures were a more accessible feature for the user to define and edit. To this day this Max paradigm \parencite{DBLP:journals/comj/Puckette02} can still be found in both widely used programs \gls{max/msp} \parencite{DBLP:conf/icmc/Zicarelli98} and Pure Data. What is important to note here, moreover, is the emphasis on Puckette's end to provide a musical instrument without stylistic constraints:

	\begin{quote}
		The design of \gls{max} goes to great lengths to avoid imposing a stylistic bias on the musician's output. To return to the piano analogy, although pianos might impose constraints on the composer or pianist, a wide variety of styles can be expressed through it. To the musician, the piano is a vehicle of empowerment, not constraint. \parencite{DBLP:journals/comj/Puckette02}
	\end{quote}

	Puckette, therefore, aims to a certain stylistic neutrality, which he represents by the way in which the user opens the program: a blank page: ``no staves, time or key signatures, not even a notion of 'note,' and certainly none of instrumental 'voice' or 'sequence''' \parencite{DBLP:journals/comj/Puckette02}. While acknowledging that even the 'blank page' is a culturally loaded symbol referring to the use of paper in Western Art Music (much in the same way that it is favoring complexity in the above described design), Puckette reconfigured computer music design, composition, and performance with great conscience on the way in which the structure of the program resonates aesthetically.

	\paragraph{Data structures for graphic scores}
	\label{computer:datastructures}

	Puckette also implemented a feature within Pure Data to enable the creation of graphic scores for electronic music \parencite{DBLP:conf/icmc/Puckette02}. In order to do this, he contextualized his research with the SSSP original project to include graphic scores within the composition environment, the \textit{Animal} project by Lindemann and de Cecco which allowed users to ``graphically draw pictures which define complex data objects'' \parencite{DBLP:conf/icmc/Lindemann90a}, and three other cases of graphic scores used to model electroacoustic music: Stockhausen, Yuasa, and Xenakis. Puckette's data structures derive from those of the C programming language, and they can be used in relation to any type of data. Following his notion of neutrality within musical style, he resolved in avoiding graphic predeterminations, namely, the fact that the $x$-value within the graphical canvas is left unlinked with time, without intervening in the user's conception of time. Despite this significant programming decision, Puckette provided the user with a sorting function, ``on the assumption that users might often want to use Pd data collections as x-ordered sequences'' \parencite{DBLP:conf/icmc/Puckette02}.

	\paragraph{RtCMIX and the heap}
	\label{computer:rtcmix}

	In the same \gls{icmc} conference of 1997, two object-oriented languages were presented. Brad Garton and David Topper presented \gls{rtcmix} \parencite{DBLP:conf/icmc/GartonT97}, a real-time version of the \gls{cmix} program by Paul Lansky. What they described as innovative in this project is, in a similar way to the data structures for time management that Puckette presented, the scheduling capabilities of the program. In contrast to the \gls{cmix} language, which assumes a non-realtime access of objects, the

	\begin{quote}
		RTcmix event scheduling is accomplished through a binary tree, priority-queue dynamic heap\dots\footnote{A heap is a tree-based data structure with a property such keys and parent-child relationships follow a hierarchic logic.} The heap is also designed to do ``scheduling-on-the-fly,'' allowing notes to be scheduled at run-time (usually triggered by an external event, such as a \gls{midi} note being depressed). \parencite{DBLP:conf/icmc/GartonT97}
	\end{quote}

	What this means, virtually, is that the real-time problem became a scheduling problem of computing tasks. However, in the case of RtCMIX, the instruments that are instantiated ``on-the-fly'' can also establish their own \gls{tcp/ip} connection sockets in order to allow for networked access to the individual synthesizers \parencite{DBLP:conf/icmc/GartonT97}.

	\paragraph{OpenMusic}
	\label{computer:openmusic}

	The other object-oriented language was a visual programming environment for non-realtime composition called OpenMusic \parencite{DBLP:conf/icmc/AssayagAFH97}. While not a synthesis engine, the strength of this Lisp-based graphic language developed as a collaboration at IRCAM, resides in its ability to provide the composer access to a variety of sound analysis tools for composition \parencite{icmc/bbp2372.2004.004, icmc/bbp2372.2010.129}, as well as the possibility to generate algorithmic streams that output directly into a traditionally notated score. For example, OpenMusic introduced the concept of a \textit{maquette}, which is a graphic canvas upon which a heterogenous set of elements as varied as audio waveforms, scores, or piano-roll type notation can be displayed.

	\paragraph{Kyma}
	\label{computer:kyma}

	Another powerful example is the case of an object-oriented language for music composition is Kyma \parencite{DBLP:conf/icmc/Scaletti87}. It was developed by Carla Scaletti at \gls{cerl} in 1987, and it was intended to use as an interactive non-realtime composition environment with the Platypus digital signal processor. Scaletti's language was hierarchical in its structure which, as I have described above, enabled the data records to be linked, that is, to be grouped vertically and horizontally. These data structures formed together objects, enabling the composer to treat as objects any set of sounds within the composition, starting from the composition itself as an object. In such a way: ``\dots the composer could create a `sound universe,' endow the sound objects in this universe with certain properties and relationships, and explore this universe in a logically consistent way'' \parencite[50]{DBLP:conf/icmc/Scaletti87}'' Therefore, and given the ``vast amounts of data required for sound synthesis'' \parencite[50]{DBLP:conf/icmc/Scaletti87}, the overall concept of Kyma was to fit the conjunction of timbre creation and temporal event lists into the same traversable database that the program proposed. What is important, however, is Scaletti's intention. In much the same way as Puckette, for Scaletti ``the language itself would not impose notational or stylistic preconceptions'' \parencite[50]{DBLP:conf/icmc/Scaletti87}.

	\paragraph{Cypher}
	\label{computer:cypher}

	\citeauthor{Row92:Int}'s interactive music system \textit{Cypher} is an object-oriented program aimed at machine listening and composition in real-time \parencite{Row92:Int}. It is constituted by two \gls{midi}-based interconnected agents, a \textit{listener} and a \textit{player}. The player outputs musical material that results from generative or transforming processes on the (machine) listened input. The listener interprets incoming streams of \gls{midi} data with \gls{mir} techniques (central pitch detection, beat tracking, among others) grouping \texttt{Note}s into larger \texttt{Event}s, and then into larger musical phrases. Both \texttt{Note} and \texttt{Event} are objects with specific data structure: the former closely linked to the \gls{midi} message, the latter forming a circular linked list that enables traversing between neighbouring \texttt{Event}s. Attached to these \texttt{Event}s, however, reside intermediary agents that each store musical information that is locally relevant to the parent \texttt{Event}. The attached information, therefore, is fundamental to the system: ``The feature space representation \dots tends to treat parameters of the sound-pressure waves carrying musical percepts as central. Register, loudness, and density are all primary components of the representation'' \parencite[Chapter~7]{Row92:Int}. This constitutes Rowe's implementation of the object-oriented model. Upon deciding which analytical model to apply to the \textit{listener} agent, however, Rowe finds a coexistence of two virtually opposing models for music analysis: a hierarchical one (Shenker, Forte, Lerdahl) and a networked one (Narmour). While extending an analysis of database models to music theory is beyond the scope of this study, it is interesting to note how the versatility of the object model can integrate two very different ways of thinking musical relationships: ``Cypher's listener and player are organized hierarchically, though these hierarchies tend toward Narmour's network ideas rather than the more strictly structured trees of Lerdahl and Jackendoff'' \parencite[Chapter~4.3]{Row92:Int}. 

	\paragraph{SuperCollider and nodes}
	\label{computer:supercollider}

	The literature on computer music software for composition alone would extend beyond the scope of this dissertation. However, there are important features to acknowledge from yet another object-oriented language for music synthesis that was developed at the end of the 1990s, namely, James McCarntney's SuperCollider \parencite{DBLP:conf/icmc/McCartney96, DBLP:conf/icmc/McCartney98}. This high-level language provides the user with a different paradigm to handle audio processes, their ordering, and ---most importantly--- their switching. The innovation that this language implemented is the ``garbage collection'' of each process. McCartney took the hierarchic structure of the object-oriented paradigm and defined `nodes' in a tree-like structure, each with its own capability of nesting groups of other nodes, but most importantly, with its own initial and expiration times. In other words, in contrast to the constantly running audio processes that Pure Data and \gls{max/msp}, SuperCollider only consumes \gls{cpu} resources whenever it needs to. This economy of resources that is enabled by the data structure of the language, together with its high-level quality, make it quite remarkable.

	For further reference in other sound synthesis data structures, see: the Diphone synthesis program \parencite{DBLP:conf/icmc/RodetDP88, Rodet1989, DBLP:conf/icmc/DepalleRGE93, DBLP:conf/icmc/RodetL96, DBLP:conf/icmc/RodetL97}; FORMES \parencite{DBLP:conf/icmc/BoyntonDPR86}; the Otkinshi system \parencite{icmc/bbp2372.2002.039}. For an overview of existing audio software up to 2004, see Xamat's PhD Dissertation \parencite[Chapter~2]{Amatriain/2004/phdthesis}. See also the Integra project \parencite{Bullock2009,Bullock2011}, Ariza's work on python's data structures \parencite{Ari05:Ano}, and Rowe's \parencite{Row92:Int, Row01:Mac}